"""
Задача 1. Максимальный урон:
    Программист Игорь очень любит играть в компьютерные игры. Больше всего Игорю нравятся стратегии, 
    особенно те моменты, когда он отправляет группы своих юнитов атаковать вражеские базы. 
    Игорь довольно давно играет в стратегии, поэтому у него есть чётко отработанный план действий 
    при атаке: он разбивает все свои юниты на группы и отправляет их в атаку поочередно. При этом Игорь 
    считает, что общий урон, который будет нанесен в атаке, равен произведению размеров групп. 
    Он пытается разбить свои юниты на группы так, чтобы максимизировать общий урон.
    В последнее время Игорь стал часто проигрывать. Он уверен, что проблема в том, что в одной 
    из групп после разбиения получается несчастливое количество юнитов. Он пытается переделать 
    свой алгоритм разбиения и попросил вас посчитать, какой максимальный общий урон смогут нанести его группы, 
    если среди них не будет ни одной, содержащей несчастливое количество юнитов.

Формат ввода:
    В единственной строке входных данных через пробел записаны натуральные числа n и a 
    (1 ≤ n, a ≤ 1e6, n ≠ a) — количество юнитов, которые есть у Игоря, и число юнитов в группе, 
    которое Игорь считает несчастливым.

Формат вывода:
    Выведите максимально возможный общий урон по модулю 1e9 + 7
"""

n, a = [int(i) for i in input().split()]
mod = int(1e9 + 7)
if n == 1:
    res = n
elif a == 3:  # если несчастливое число - 3
    if n % 2 == 1:  # одна группа по 5 юнитов, а остальные по 2 юнита
        res = pow(2, (n - 5) // 2, mod) * 5 % mod
    else:  # разбиваем группы по 2 юнита
        res = pow(2, n // 2, mod)
elif a == 2:  # если несчастливое число - 3
    if n == 5:  # оставляем одну группу из 5
        res = 5
    elif n % 3 == 0:  # разбиваем группы по 3 юнита
        res = pow(3, n // 3, mod)
    elif n % 3 == 1:  # одна группа по 4 юнита, а остальные по 3 юнита
        res = pow(3, (n - 4) // 3, mod) * 4 % mod
    else:  # две группы по 4 юнита, а остальные по 3 юнита
        res = (pow(3, (n - 8) // 3, mod) * 4 % mod) * 4 % mod
else:  # если несчастливое число не 2, не 3
    if n % 3 == 0:  # разбиваем группы по 3 юнита
        res = pow(3, n // 3, mod)
    elif n % 3 == 1:  # одна группа по 4 юнита, а остальные по 3 юнита
        res = pow(3, (n - 4) // 3, mod) * 4 % mod
    else:  # одна группа по 2 юнита, а остальные по 3 юнита
        res = pow(3, (n - 2) // 3, mod) * 2 % mod

print(res)
